<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Shadowverse — Crystal Echoes (v1.1)</title>
  <style>
    :root{--bg:#0B0F12;--bg2:#0E151A;--ink:#E7ECEF;--weak:#B8C2C8;--line:#1F2A31;--teal:#51E4DC;--slate:#3C7189;--gold:#D2B48C;--glow:#7FE7E0}
    html,body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    header{max-width:1200px;margin:18px auto 8px;padding:0 14px;display:grid;gap:10px;grid-template-columns:1fr auto;align-items:center}
    header h1{font-size:16px;font-weight:700;margin:0;color:var(--teal);letter-spacing:.02em}
    .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    button{background:#12181C;border:1px solid var(--line);color:var(--ink);padding:8px 12px;border-radius:10px;cursor:pointer}
    button:hover{background:var(--bg2)}
    main{position:relative}
    canvas{display:block;margin:0 auto}
    .stats{max-width:1200px;margin:8px auto;padding:0 14px;display:grid;grid-template-columns:repeat(auto-fit,minmax(120px,1fr));gap:10px;font-size:13px}
    .stat{background:var(--bg2);padding:8px 12px;border-radius:10px}
    .stat-label{color:var(--weak);font-size:11px;text-transform:uppercase}
    .stat-value{font-weight:700;font-size:18px;letter-spacing:-.02em}
    .stat-value.grade-S{color:var(--glow)} .stat-value.grade-A{color:var(--teal)}
    .stat-value.grade-B{color:var(--ink)}  .stat-value.grade-C{color:var(--weak)}
    .fail-overlay{position:fixed;inset:0;background:rgba(0,0,0,0.8);display:none;align-items:center;justify-content:center;text-align:center;z-index:100}
    .fail-box{background:var(--bg);padding:30px;border-radius:20px;border:1px solid var(--line)}
    .fail-box h2{margin:0 0 10px;color:var(--teal)}
    .calibration-overlay{position:fixed;inset:0;background:rgba(11,15,18,.95);display:none;flex-direction:column;align-items:center;justify-content:center;z-index:200}
    .calibration-box{text-align:center} .calibration-box p{color:var(--weak);max-width:420px;margin-bottom:20px}
    .cal-bar-container{width:320px;height:20px;background:var(--bg2);border:1px solid var(--line);border-radius:5px;position:relative;overflow:hidden;margin:20px 0}
    .cal-bar-marker{position:absolute;top:0;bottom:0;width:4px;background:var(--teal);left:50%;transform:translateX(-50%)}
    .cal-bar-hit{position:absolute;top:0;bottom:0;width:4px;background:var(--gold);transform:translateX(-50%);transition:left .1s}
  </style>
</head>
<body>
  <header>
    <h1>Shadowverse — Crystal Echoes (v1.1)</h1>
    <div class="controls">
      <button id="btnCalibrate">Calibrate Latency</button>
      <button id="btnStart">Start</button>
      <button id="btnPause">Pause</button>
      <button id="btnRestart">Restart</button>
      <label><input type="checkbox" id="metronome"> Metronome</label>
    </div>
  </header>

  <main><canvas id="c" width="1200" height="420"></canvas></main>

  <div class="stats">
    <div class="stat"><div class="stat-label">Time</div><div id="statTime" class="stat-value">0.0s</div></div>
    <div class="stat"><div class="stat-label">Beat</div><div id="statBeat" class="stat-value">Bar 1 • Beat 1</div></div>
    <div class="stat"><div class="stat-label">Score</div><div id="statScore" class="stat-value">0</div></div>
    <div class="stat"><div class="stat-label">Combo</div><div id="statCombo" class="stat-value">0</div></div>
    <div class="stat"><div class="stat-label">Grade</div><div id="statGrade" class="stat-value grade-C">C</div></div>
  </div>

  <div id="fail" class="fail-overlay"><div class="fail-box">
    <h2>Fractured</h2><p>The echo was lost.</p><button id="btnRetry">Retry</button>
  </div></div>

  <div id="calibration" class="calibration-overlay">
    <div class="calibration-box">
      <h2>Latency Calibration</h2>
      <p>Tap or press any key in time with the pulse. Do this 5× to learn your system offset.</p>
      <button id="btnStartCal">Start Calibration</button>
      <div class="cal-bar-container" style="display:none;">
        <div class="cal-bar-marker"></div><div id="calHit" class="cal-bar-hit"></div>
      </div>
      <p id="calResult"></p><button id="btnCloseCal" style="display:none;">Close</button>
    </div>
  </div>

<script>
/* ========= Core Tunables ========= */
const BPM = 120;                    // render tempo (can swap later)
const beatSec = 60 / BPM;
const pxPerMs = 0.22;               // scroll speed (ms -> px)
const runnerX = 180;                // runner X position
const lanesY  = [220, 280, 340];    // top/mid/bot Y positions
let   PERFECT = 0.05, GREAT = 0.10, GOOD = 0.15; // seconds (tweak while testing)

/* ========= DOM ========= */
const c = document.getElementById('c'), ctx = c.getContext('2d');
const btnStart  = document.getElementById('btnStart');
const btnPause  = document.getElementById('btnPause');
const btnRestart= document.getElementById('btnRestart');
const btnRetry  = document.getElementById('btnRetry');
const chkMet    = document.getElementById('metronome');
const fail      = document.getElementById('fail');
const statTime  = document.getElementById('statTime');
const statBeat  = document.getElementById('statBeat');
const statScore = document.getElementById('statScore');
const statCombo = document.getElementById('statCombo');
const statGrade = document.getElementById('statGrade');

/* ========= Audio ========= */
let ac=null;
function ensureAudio(){ if(!ac) ac=new (window.AudioContext||window.webkitAudioContext)(); }
function blip(f=880,a=0.005,d=0.12,type='sine'){
  if(!ac) return; const t=ac.currentTime; const o=ac.createOscillator(), g=ac.createGain();
  o.type=type; o.frequency.value=f; o.connect(g); g.connect(ac.destination);
  g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(0.4,t+a);
  g.gain.exponentialRampToValueAtTime(0.001,t+a+d); o.start(t); o.stop(t+a+d);
}
const SFX={ jump:()=>blip(220,0.005,0.10,'sine'),
            perfect:()=>blip(1100,0.004,0.15,'triangle'),
            great:()=>blip(880,0.004,0.15,'triangle'),
            good:()=>blip(660,0.004,0.12,'triangle'),
            miss:()=>{ if(!ac) return; const t=ac.currentTime;
              const b=ac.createBuffer(1, ac.sampleRate*0.18, ac.sampleRate);
              const d=b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
              const s=ac.createBufferSource(); s.buffer=b; const g=ac.createGain();
              g.gain.setValueAtTime(0.3,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.18);
              s.connect(g).connect(ac.destination); s.start(t); } };

/* ========= Metronome (single block) ========= */
let metCtx=null, metGain=null;
function ensureMet(){ if(metCtx) return;
  metCtx=new (window.AudioContext||window.webkitAudioContext)();
  metGain=metCtx.createGain(); metGain.gain.value=0.0; metGain.connect(metCtx.destination);
}
function scheduleMet(){
  ensureMet();
  const beats = 4*32;                // schedule ~32 bars
  const base  = metCtx.currentTime + 0.05;
  for(let i=0;i<beats;i++){
    const osc=metCtx.createOscillator(), env=metCtx.createGain();
    osc.frequency.value = (i%4===0)?1000:800;
    osc.connect(env); env.connect(metGain);
    const t = base + i*beatSec;
    env.gain.setValueAtTime(0, t);
    env.gain.linearRampToValueAtTime(0.4, t+0.002);
    env.gain.exponentialRampToValueAtTime(0.001, t+0.08);
    osc.start(t); osc.stop(t+0.1);
  }
  metGain.gain.value = chkMet.checked ? 0.25 : 0.0;
}

/* ========= Chart (string -> actions) ========= */
const CHART = "1---2---1---3---1-2-1---S--|1---2---1---3---1-2-1---4---|1---2---1---3---1-2-1---S--|1---2---1---3---1-2-1---4---";
let actions=[], hazards=[];
function buildChart(){
  actions.length=0; hazards.length=0;
  let beat=0;
  for(const ch of CHART){
    const t = beat * beatSec * 1000;
    if("123".includes(ch)){ const lane = parseInt(ch)-1;
      actions.push({time:t, lane, type:'JUMP', hit:false});
      hazards.push({time:t, lane, cleared:false});         // <-- clearable
    } else if(ch==='4'){ const lane=1; // mirror moment (rendered as hazard too)
      actions.push({time:t, lane, type:'MIRROR', hit:false});
      hazards.push({time:t, lane, cleared:false});
    } else if(ch==='S'){ // shadow triplet
      [0,1,2].forEach(l=>actions.push({time:t, lane:l, type:'SHADOW', hit:false}));
    }
    beat += (ch==='|'?0:0.5);
  }
}
buildChart();

/* ========= Game State ========= */
let running=false, startMs=0, elapsed=0, y=0, vy=0, score=0, combo=0, grade='C';
let perfects=0, greats=0, goods=0, misses=0, fracture=0, glow=0;
let offsetMs = 0;
let lastHitTime = -1;                // used for grace window

/* ========= Loop ========= */
function loop(){ if(!running) return;
  elapsed = performance.now() - startMs + offsetMs;
  update(); draw(); requestAnimationFrame(loop);
}
function update(){
  vy += 0.6; y = Math.min(0, y+vy);     // clamp to ground
  fracture *= 0.9; glow *= 0.9;

  // auto-miss scan
  for(const a of actions){
    if(!a.hit && elapsed > a.time + GOOD*1000){
      a.hit='miss'; misses++; combo=0; fracture=1; SFX.miss();
    }
  }

  const b = elapsed/1000/beatSec;
  const bar = Math.floor(b/4)+1, beat = Math.floor(b%4)+1;
  statTime.textContent = (elapsed/1000).toFixed(1)+'s';
  statBeat.textContent = `Bar ${bar} • Beat ${beat}`;
  statScore.textContent= score; statCombo.textContent= combo;

  const total = perfects+greats+goods+misses;
  if(total>0){
    const p = (perfects*3 + greats*2 + goods) / (total*3);
    grade = (p>0.97 && misses===0) ? 'S' : p>0.90 ? 'A' : p>0.80 ? 'B':'C';
  }
  statGrade.textContent = grade;
  statGrade.className = 'stat-value grade-'+grade;
}
function draw(){
  const w = Math.min(1200, window.innerWidth-28); if(c.width!==w) c.width=w;
  c.height=420; ctx.clearRect(0,0,c.width,c.height);
  drawBG(); drawLanes(); drawHazards(); drawRunner(); drawFX();
}
function drawBG(){
  const g = ctx.createLinearGradient(0,0,0,c.height);
  g.addColorStop(0,'#0B0F12'); g.addColorStop(1,'#0E151A');
  ctx.fillStyle=g; ctx.fillRect(0,0,c.width,c.height);
}
function drawLanes(){ ctx.fillStyle='#122027'; lanesY.forEach(y=> ctx.fillRect(0,y,c.width,3)); }
function drawRunner(){
  ctx.save(); ctx.translate(runnerX, lanesY[1] + y);
  if(glow>0.01){ ctx.shadowColor='rgba(127,231,224,.8)'; ctx.shadowBlur=18*glow; }
  ctx.fillStyle='var(--teal)'; ctx.fillRect(-12,-20,24,24);
  ctx.restore();
}
function drawHazards(){
  ctx.fillStyle='#9dd6ff';
  const now=elapsed;
  for(const h of hazards){
    if(h.cleared) continue;                            // <-- skip cleared
    const dt = h.time - now;
    const x  = runnerX + dt*pxPerMs;
    if(x<-30 || x>c.width+30) continue;
    const y  = lanesY[h.lane];
    ctx.fillRect(x-10,y-10,20,20);

    // 150 ms grace after a hit to avoid same-frame collision
    const grace = (lastHitTime >= 0) && (now - lastHitTime <= 150);
    if(!grace && Math.abs(x-runnerX)<18 && Math.abs(y - lanesY[1])<18){
      running=false; fail.style.display='flex';
    }
  }
}
function drawFX(){
  // grain
  ctx.globalAlpha=0.06;
  for(let i=0;i<200;i++){
    ctx.fillStyle='rgba(255,255,255,.6)';
    ctx.fillRect(Math.random()*c.width,Math.random()*c.height,1,1);
  }
  ctx.globalAlpha=1;
  // vignette
  const vg=ctx.createRadialGradient(c.width/2,c.height/2, c.height*.35, c.width/2,c.height/2, c.height*.85);
  vg.addColorStop(0,'rgba(0,0,0,0)'); vg.addColorStop(1,'rgba(0,0,0,.35)');
  ctx.fillStyle=vg; ctx.fillRect(0,0,c.width,c.height);
  // fracture shake (subtle, handled in update visuals)
}

/* ========= Judging ========= */
function soonestMid(){ // runner is on middle lane (index 1)
  return actions.filter(a=>!a.hit && a.lane===1).sort((x,y)=>x.time-y.time)[0];
}
function hitNote(a, tier, base){
  a.hit = true;
  if(tier==='perfect'){ perfects++; glow=1;   SFX.perfect(); }
  else if(tier==='great'){ greats++; glow=0.6; SFX.great(); }
  else { goods++; glow=0.3; SFX.good(); }

  combo++; score += base + combo;
  clearHazard(a);              // <-- remove matching hazard
  lastHitTime = elapsed;       // <-- grace window anchor
  update();                    // refresh HUD quickly
}
function judge(){
  const a = soonestMid(); if(!a) return;
  const d = Math.abs(a.time - elapsed)/1000;
  if(d<=PERFECT) hitNote(a,'perfect',300);
  else if(d<=GREAT) hitNote(a,'great',200);
  else if(d<=GOOD) hitNote(a,'good',100);
  // else: miss scanner will mark it
}
function clearHazard(a){
  const tol = beatSec*1000*0.25; // 1/4 beat tolerance
  const h = hazards.find(h=>!h.cleared && h.lane===a.lane && Math.abs(h.time-a.time)<tol);
  if(h) h.cleared = true;
}

/* ========= Controls ========= */
btnStart.onclick = ()=>{ if(running) return; ensureAudio();
  if(chkMet.checked) scheduleMet();
  running=true; fail.style.display='none'; startMs=performance.now(); fracture=0; glow=0; loop();
};
btnPause.onclick = ()=>{ running=false; };
btnRestart.onclick = ()=>{ running=false; fail.style.display='none';
  score=combo=perfects=greats=goods=misses=0; actions.forEach(a=>a.hit=false);
  buildChart(); elapsed=0; startMs=performance.now(); draw();
};
btnRetry.onclick = ()=>{ fail.style.display='none'; btnRestart.onclick(); btnStart.onclick(); };
window.addEventListener('keydown',e=>{ if(!running) return;
  if(e.code==='Space'){ ensureAudio(); vy=-10; SFX.jump(); judge(); }
});
window.addEventListener('mousedown',()=>{ if(!running) return; ensureAudio(); vy=-10; SFX.jump(); judge(); });

/* ========= Calibration ========= */
const overlay = document.getElementById('calibration');
const btnStartCal = document.getElementById('btnStartCal');
const btnCloseCal = document.getElementById('btnCloseCal');
const calBar = document.querySelector('.cal-bar-container');
const calHit = document.getElementById('calHit');
const calResult = document.getElementById('calResult');
let calOn=false, calPulse=false, taps=[];
document.getElementById('btnCalibrate').onclick = ()=>{ ensureAudio(); overlay.style.display='flex'; };
btnStartCal.onclick = ()=>{ calOn=true; taps.length=0; btnStartCal.style.display='none'; calBar.style.display='block';
  calResult.textContent='Tap with the pulse (5×)…'; requestAnimationFrame(calLoop); };
btnCloseCal.onclick = ()=>{ overlay.style.display='none'; btnStartCal.style.display='inline-block'; btnCloseCal.style.display='none'; calBar.style.display='none'; calResult.textContent=''; };
function calLoop(){ if(!calOn) return;
  const now=performance.now()/1000, cyc = now%1; calHit.style.left = (cyc*100)+'%';
  if(cyc<0.05 && !calPulse){ blip(1000,0.004,0.08,'sine'); calPulse=true; }
  if(cyc>0.05) calPulse=false; requestAnimationFrame(calLoop);
}
function recordTap(){
  if(!calOn) return;
  const cyc = (performance.now()/1000)%1;
  const offset = (cyc>0.5 ? cyc-1 : cyc)*1000; // ms around 0
  taps.push(offset); calResult.textContent=`Hit ${taps.length}/5 (${offset.toFixed(0)}ms)`;
  if(taps.length>=5){ calOn=false;
    const avg = Math.round(taps.reduce((a,b)=>a+b,0)/taps.length);
    offsetMs = -avg; // apply inverse
    calResult.textContent = `Done. Applied ${(-avg)}ms offset.`;
    btnCloseCal.style.display='inline-block';
  }
}
window.addEventListener('keydown',e=>{ if(calOn) recordTap(); });
window.addEventListener('mousedown',()=>{ if(calOn) recordTap(); });

/* ========= Boot ========= */
window.addEventListener('resize',draw);
buildChart(); draw();
</script>
</body>
</html>